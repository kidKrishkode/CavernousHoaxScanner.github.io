let mediaType, url, dfd;
let converter;
let compressor;
let pdf;
class DFD{
  constructor(){
    this.active = true;
    this.signal = null;
  }
}
class CONVERTER{
  constructor(){
    this.active = true;
    this.signal = null;
  }
}
class COMPRESSOR{
  constructor(){
    this.active = true;
    this.signal = null;
  }
}
class IMGTOPDF{
  constructor(){
    this.active = true;
    this.signal = null;
    this.imgSet = [];
    this.view = 0;
  }
}
document.addEventListener("DOMContentLoaded",() => {
  dfd = new DFD();
  converter = new CONVERTER();
  compressor = new COMPRESSOR();
  pdf = new IMGTOPDF();
});
DFD.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else if(file.type.startsWith('video/')){
            let video = document.createElement('video');
            video.autoplay = true;
            video.controls = true;
            video.muted = true;
            let source = document.createElement('source');
            source.src = dataURL;
            source.type = 'video/mp4';
            video.appendChild(source);
            preview.appendChild(video);
            mediaType = 'Video'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
DFD.prototype.getVideoDuration = function(videoPath){
  return new Promise((resolve, reject) => {
    var video = document.createElement('video');
    video.preload = 'metadata';
    video.onloadedmetadata = function(){
      var duration = video.duration;
      var xhr = new XMLHttpRequest();
      xhr.open('HEAD', videoPath, true);
      xhr.onreadystatechange = function(){
        if(xhr.readyState === 4){
          resolve({ duration });
        }
      };
      xhr.send();
    };
    video.onerror = function(){
      reject('Error to loading video');
    };
    video.src = videoPath;
  });
}
DFD.prototype.displayVinfo = function(path){
  this.getVideoDuration(path).then(info => {
    return Math.round(info.duration);
  }).catch(error => {
    console.error(error);
  });
}
DFD.prototype.engine_start = function(){
  this.engine_active();
}
DFD.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let exc = document.getElementById('media-exc');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let dur = document.getElementById('media-due');
  let dim = document.getElementById('media-diamention');
  this.mediaChange().then(media => {
    let extension = String(media).split('/')[1].split(';')[0];
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      let dimensions = getMediaDimensions();
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        this.signal = true;
        size.textContent = temp+' Kb';
        dur.textContent = 'Static, 0s';
        dim.textContent = dimensions?.width+"x"+dimensions?.height;
        exc.textContent = extension;
      }else{
        inValidsizeError(temp);
        this.signal = false;
      }
    }else if(media[0] == 'Video'){
      let temp = Filevalidation(400 * 1024, 20);
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        this.signal = true;
        size.textContent = temp+' Kb';
        exc.textContent = extension;
        setTimeout(() => {
          let dimensions = getMediaDimensions();
          dim.textContent = dimensions?.width+"x"+dimensions?.height;
        }, 1000);
        this.getVideoDuration(media[1]).then(info => {
          dur.textContent = Math.round(info.duration)+' s';
        }).catch(error => {
          console.error(error);
          acc.textContent = 'Video inner data is corrupted!';
          this.signal = false;
        });
      }else{
        inValidsizeError(temp);
        this.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      this.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
DFD.prototype.sampledfd = async function(index){
  let img_url = `../assets/bin/${index+2}.png`;
  const preview = document.querySelector('.preview');
  preview.innerHTML = `<img src=${img_url} alt="loading.." />`;
  const fileInput = document.getElementById("file-input");
  const base64Data = await getMediaBase64(img_url);
  if(base64Data.startsWith('data:image/')){
    const file = base64ToFile(base64Data);
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change'));
    sampleUpload(index);
  }else{
    alert("Oops server not provided the media access to calculate!");
  }
}
function inValidsizeError(message){
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  acc.textContent = message;
  size.textContent = 'Null';
  try{
    system.handelPyError({code: 413, message: "The request media was larger than limits defined by CHS (lookup our media size restriction point in privacy page or docs page), please try something different media.."});
  }catch(e){
    alert("Media size is not processable, please try something different!");
  }
}
function Filevalidation(max, min){
  const fi = document.getElementById('file-input');
  const validFiles = eval(config.hex.vaildFiles);
  return validFiles(fi, max, min);
}
function getMediaDimensions(){
  let preview = document.querySelector('.preview');
  let media = preview.children[0];
  let dimensions;
  if(media.tagName.toLowerCase() === 'img'){
    dimensions = {
      width: media.naturalWidth,
      height: media.naturalHeight
    };
  }else if(media.tagName.toLowerCase() === 'video'){
    dimensions = {
      width: media.videoWidth,
      height: media.videoHeight
    };
  }else{
    dimensions = null;
  }
  return dimensions;
}

IMGTOPDF.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      for(let i=0; i<e.target.files.length; i++){
        let file = e.target.files[i];
        if(file){
          const reader = new FileReader();
          reader.onload = () => {
            const dataURL = reader.result;
            if(file.type.startsWith('image/')){
              mediaType = 'Image'; 
              this.imgSet[this.imgSet.length] = dataURL;
              resolve([mediaType, dataURL, e.target.files.length]);
            }else{
              reject('Unwanted media formate detected!');
            }
          };
          reader.readAsDataURL(file);
        }
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
IMGTOPDF.prototype.engine_start = function(){
  this.engine_active();
}
IMGTOPDF.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let count = document.getElementById('media-count');
  this.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      if(temp>=0){
        type.textContent = 'pdf (image)';
        acc.textContent = "Accepted";
        this.signal = true;
        size.textContent = 'calculating..';
        count.textContent = media[2];
        this.setView();
        document.querySelector('.view-image').innerHTML = `<div class="btn btn-process" onclick="pdf.openView();"><i class="fa fa-eye"></i> View Images</div>`;
      }else{
        inValidsizeError(temp);
        this.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      this.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
IMGTOPDF.prototype.setView = function(){
  try{
    setTimeout(()=>{
      if(this.imgSet.length!=0){
        document.querySelector('.view-image').style.display = "block";
        let size = document.getElementById('media-size');
        size.textContent = Math.round(getMultiImageSizeKB(this.imgSet))+' Kb';
        let count = document.getElementById('media-count');
        count.textContent = this.imgSet.length;
        if(this.view!=0){
          document.body.removeChild(document.getElementById('pdfPreview'));
        }
        let temp = `<div class="workspace blbg" style="background: #0000009e;" id="pdfPreview"><div class="pdfView"><header class="flx"><img src="../public/favicon.ico" alt="load"/><div class="btn btn-outline-info dropdown-toggle" data-toggle="dropdown" onclick="pdf.sortView();">Re-Order</div><span style="cursor: pointer;" onclick="pdf.closeView();">&times;</span></header><div class="view">`;
        for(let i=0; i<this.imgSet.length; i++){
          temp += `<div class="page" draggable="true"><div class="img"><img src="${this.imgSet[i]}" alt="load" class="imp"/></div><div class="index">${i+1}</div></div>`;
        }
        temp += `</div></div></div>`;
        document.body.innerHTML += temp;
        this.view = 1;
      }
    },1000);
    document.querySelector('.placeholder').innerHTML = `<i class="fa fa-file-image-o" style="font-size: 30px;"></i><br>Select more images(${this.imgSet.length}+) to add on pdf file`;
  }catch(e){
    console.log("Can't able to open Pdf view!");
  }
}
IMGTOPDF.prototype.sortView = function(){
  try{
    this.view=2;
    const element = document.getElementById("pdfPreview");
    const view = element.querySelector(".view");
    let temp = '<ul id="sortable">';
    let date = `${new Date().getDate()<10?'0'+new Date().getDate():new Date().getDate()}/${(new Date().getMonth()+1)<10?'0'+(new Date().getMonth()+1):(new Date().getMonth()+1)}/${new Date().getFullYear()}`;
    for(let i=0; i<this.imgSet.length; i++){
      temp += `<li class="flo" draggable="true"><span>Index: ${i+1}</span><img src="${this.imgSet[i]}" class="pdf-img" alt="load" width="30" height="42"/><span>Author: User</span><span>Modified: ${date}</span><span>Type: Image</span></li>`;
    }
    temp += '</ul>';
    view.innerHTML = temp;
    setTimeout(()=>{
      const sortableList = document.getElementById("sortable");
      const dragAndSort = eval(config.hex.dragAndSort);
      dragAndSort(sortableList);
    },1000);
  }catch(e){
    console.log("Can't able to open short view!");
  }
}
IMGTOPDF.prototype.openView = function(){
  if(this.view==2){
    document.body.removeChild(document.getElementById('pdfPreview'));
    this.view=0;
    this.setView();
  }
  setTimeout(()=>{
    document.getElementById('pdfPreview').style.display = "block";
    document.body.style.overflowY = "hidden";
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  },1000);
}
IMGTOPDF.prototype.closeView = function(){
  document.getElementById('pdfPreview').style.display = "none";
  document.body.style.overflowY = "auto";
}
CONVERTER.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
CONVERTER.prototype.engine_start = function(){
  this.engine_active();
}
CONVERTER.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let exc = document.getElementById('media-exc');
  let size = document.getElementById('media-size');
  let dim = document.getElementById('media-diamention');
  this.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      let dimensions = getMediaDimensions();
      let extension = String(media).split('/')[1].split(';')[0];
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        this.signal = true;
        size.textContent = temp+' Kb';
        dim.textContent = dimensions?.width+"x"+dimensions?.height;
        exc.textContent = extension;
      }else{
        inValidsizeError(temp);
      }
    }else{
      console.warn("Engine not work!");
    }
  }).catch(e => {
    console.log(e);
  });
}

COMPRESSOR.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
COMPRESSOR.prototype.engine_start = function(){
  this.engine_active();
}
COMPRESSOR.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let exc = document.getElementById('media-exc');
  let size = document.getElementById('media-size');
  let dim = document.getElementById('media-diamention');
  this.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      let dimensions = getMediaDimensions();
      let extension = String(media).split('/')[1].split(';')[0];
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        this.signal = true;
        size.textContent = temp+' Kb';
        dim.textContent = dimensions?.width+"x"+dimensions?.height;
        exc.textContent = extension;
      }else{
        inValidsizeError(temp);
      }
    }else{
      console.warn("Engine not work!");
    }
  }).catch(e => {
    console.log(e);
  });
}

function getBase64SizeKB(base64) {
  const base64Str = base64.split(',')[1] || base64;

  const padding = (base64Str.endsWith('==')) ? 2 : (base64Str.endsWith('=')) ? 1 : 0;
  const bytes = (base64Str.length * 3) / 4 - padding;

  return bytes / 1024;
}

async function compressBase64Image(base64_image, maxSizeKB = 900, minSkipSizeKB = 600) {
  function base64SizeKB(base64) {
    let len = base64.length * (3 / 4) - (base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0);
    return len / 1024;
  }

  if (base64SizeKB(base64_image) < minSkipSizeKB) {
    // Skip compression if already small enough
    return base64_image;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      let quality = 0.95;
      let compressedBase64;

      // Iteratively reduce quality until under maxSizeKB or minimum threshold
      while (quality >= 0.1) {
        compressedBase64 = canvas.toDataURL("image/jpeg", quality);
        const sizeKB = base64SizeKB(compressedBase64);

        if (sizeKB <= maxSizeKB) break;
        quality -= 0.05;
      }

      resolve(compressedBase64);
    };
    img.onerror = () => reject("Failed to load image for compression.");
    img.src = base64_image;
  });
}

function compressBase64Video(base64Video, targetMaxSizeMB = 10, minSkipSizeKB = 900) {
  const sizeKB = getBase64SizeKB(base64Video);
  if (sizeKB < minSkipSizeKB) {
    return Promise.resolve(base64Video); // No need to compress
  }

  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const blob = base64ToBlob(base64Video, 'video/mp4');
    const url = URL.createObjectURL(blob);

    video.src = url;
    video.crossOrigin = 'anonymous';
    video.muted = true;
    video.playsInline = true;

    video.addEventListener('loadedmetadata', () => {
      const stream = video.captureStream();
      const chunks = [];
      const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm',
        videoBitsPerSecond: 500_000, // compression control
      });

      recorder.ondataavailable = (e) => chunks.push(e.data);
      recorder.onstop = () => {
        const compressedBlob = new Blob(chunks, { type: 'video/webm' });
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result); // Return base64
        reader.onerror = reject;
        reader.readAsDataURL(compressedBlob);
        URL.revokeObjectURL(url);
      };

      recorder.start();
      video.play();

      setTimeout(() => {
        recorder.stop();
        video.pause();
      }, Math.min(video.duration * 1000, 40000)); // up to 40s or full duration
    });

    video.onerror = () => {
      reject("Video failed to load. Ensure base64 is valid and browser supports video playback.");
    };
  });
}


function base64ToBlob(base64, mimeType) {
  const base64Data = base64.split(',')[1] || base64;
  const byteChars = atob(base64Data);
  const byteArrays = [];
  for (let i = 0; i < byteChars.length; i += 512) {
    const slice = byteChars.slice(i, i + 512);
    const byteNumbers = new Array(slice.length);
    for (let j = 0; j < slice.length; j++) {
      byteNumbers[j] = slice.charCodeAt(j);
    }
    byteArrays.push(new Uint8Array(byteNumbers));
  }
  return new Blob(byteArrays, { type: mimeType });
}

async function extractFramesFromBase64Video(base64Video, fps = 1) {
    return new Promise((resolve, reject) => {
        const frames = [];

        // Create a video element
        const video = document.createElement('video');
        video.src = base64Video;
        video.crossOrigin = 'anonymous';
        video.preload = 'auto';
        video.muted = true;
        video.playsInline = true;

        video.addEventListener('loadedmetadata', () => {
            const duration = Math.floor(video.duration);
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            let currentTime = 0;

            function captureFrame() {
                video.currentTime = currentTime;
            }

            video.addEventListener('seeked', () => {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const base64Image = canvas.toDataURL('image/jpeg'); // or 'image/png'
                frames.push({ second: currentTime, image: base64Image });

                currentTime += 1;
                if (currentTime <= video.duration) {
                    captureFrame();
                } else {
                    resolve(frames);
                }
            });

            captureFrame();
        });

        video.addEventListener('error', (e) => reject(`Video error: ${e.message || e}`));
    });
}

function analyzeClassificationSequence(predictions) {
  if (!predictions || predictions.length === 0) {
      return { error: "Empty prediction list" };
  }

  let resultClass = "Real";
  let fakeSequences = [];
  let currentSequence = [];

  for (let i = 0; i < predictions.length; i++) {
      const item = predictions[i];
      const label = (item.class || "").toLowerCase();

      if (label === "fake") {
          currentSequence.push(item);
          if (currentSequence.length >= 2) {
              fakeSequences = [...currentSequence]; // copy
          }
      } else {
          currentSequence = [];
      }
  }

  if (fakeSequences.length > 0) {
      const totalAccuracy = fakeSequences.reduce((sum, f) => sum + f.accuracy, 0);
      const avgAccuracy = +(totalAccuracy / fakeSequences.length).toFixed(2);
      const startTime = fakeSequences[0].second;
      const endTime = fakeSequences[fakeSequences.length - 1].second;

      return {
          class: "Fake",
          accuracy: avgAccuracy,
          period: [startTime, endTime]
      };
  }

  // No valid fake sequence found, evaluate real data
  const realPreds = predictions.filter(p => (p.class || "").toLowerCase() === "real");
  if (realPreds.length > 0) {
      const totalAccuracy = realPreds.reduce((sum, p) => sum + p.accuracy, 0);
      const avgAccuracy = +(totalAccuracy / realPreds.length).toFixed(2);
      const startTime = realPreds[0].second;
      const endTime = realPreds[realPreds.length - 1].second;

      return {
          class: "Real",
          accuracy: avgAccuracy,
          period: [startTime, endTime]
      };
  }

  return { error: "No valid classification data" };
}

function loosParameterRecover(){
  return {
    "prototype_1": {"class": "Real", "accuracy": 50}, 
    "prototype_2": {"class": "Fake", "accuracy": 50}, 
    "prototype_3": {"class": "Fake", "accuracy": 50}
  }
}

function summarizePrototypeResults(response_tree) {
  const summary = {};

  response_tree.forEach(entry => {
      for (let proto in entry) {
          const result = entry[proto];
          const label = result.class.toLowerCase();
          const accuracy = result.accuracy;

          if (!summary[proto]) {
              summary[proto] = {
                  real: { count: 0, totalAccuracy: 0 },
                  fake: { count: 0, totalAccuracy: 0 }
              };
          }

          if (label === "real") {
              summary[proto].real.count += 1;
              summary[proto].real.totalAccuracy += accuracy;
          } else if (label === "fake") {
              summary[proto].fake.count += 1;
              summary[proto].fake.totalAccuracy += accuracy;
          }
      }
  });

  const resultList = [];

  for (let proto in summary) {
      const real = summary[proto].real;
      const fake = summary[proto].fake;

      let finalClass, finalAccuracy;

      if (fake.count > real.count) {
          finalClass = "Fake";
          finalAccuracy = +(fake.totalAccuracy / fake.count).toFixed(2);
      } else {
          finalClass = "Real";
          finalAccuracy = +(real.totalAccuracy / real.count).toFixed(2);
      }

      resultList[proto] = {
          class: finalClass,
          accuracy: finalAccuracy
      };
  }

  return resultList;
}

function getAspectRatio(width, height) {
  const inputRatio = width / height;
  
  // Define standard ratios
  const ratios = {
      "16:9": 16 / 9,
      "9:16": 9 / 16,
      "1:1": 1,
      "3:2": 3 / 2,
      "2:3": 2 / 3,
      "4:3": 4 / 3,
      "3:4": 3 / 4,
      "7:5": 7 / 5,
      "7:4": 7 / 4,
      "5:4": 5 / 4,
      "4:5": 4 / 5,
      "5:7": 5 / 7
  };

  let closestMatch = 'custom';
  let smallestDiff = Infinity;

  for (const [label, ratio] of Object.entries(ratios)) {
      const diff = Math.abs(inputRatio - ratio);
      if (diff < 0.05) {  // allow small tolerance
          if (diff < smallestDiff) {
              smallestDiff = diff;
              closestMatch = label;
          }
      }
  }

  return closestMatch;
}

function toogleComparesion(id){
  document.getElementById('compare-a').style.display = "none";
  document.getElementById('compare-b').style.display = "none";
  document.getElementById(id).style.display = "block";
}
function imageComparesion(){
  var x, i;
  x = document.getElementsByClassName("img-comp-overlay");
  for(i = 0; i < x.length; i++){
      compareImages(x[i]);
  }
  function compareImages(img){
      var slider, img, clicked = 0, w, h;
      w = img.offsetWidth;
      h = img.offsetHeight;
      img.style.width = (w / 2) + "px";
      slider = document.createElement("DIV");
      slider.setAttribute("class", "img-comp-slider");
      img.parentElement.insertBefore(slider, img);
      slider.style.top = (h / 2) - (slider.offsetHeight / 2) + "px";
      slider.style.left = (w / 2) - (slider.offsetWidth / 2) + "px";
      let con = document.querySelector('.img-comp-container');
      let com = document.querySelector('#img-com-1');
      let mar = (con.offsetWidth - com.offsetWidth)/2;
      com.style.marginLeft = mar+'px';
      slider.addEventListener("mousedown", slideReady);
      window.addEventListener("mouseup", slideFinish);
      slider.addEventListener("touchstart", slideReady);
      window.addEventListener("touchend", slideFinish);
      function slideReady(e){
          e.preventDefault();
          clicked = 1;
          window.addEventListener("mousemove", slideMove);
          window.addEventListener("touchmove", slideMove);
      }
      function slideFinish(){
          clicked = 0;
      }
      function slideMove(e){
          var pos;
          if (clicked == 0) return false;
          pos = getCursorPos(e)
          if (pos < 0) pos = 0;
          if (pos > w) pos = w;
          slide(pos);
      }
      function getCursorPos(e){
          var a, x = 0;
          e = (e.changedTouches) ? e.changedTouches[0] : e;
          a = img.getBoundingClientRect();
          x = e.pageX - a.left;
          x = x - window.pageXOffset;
          return x;
      }
      function slide(x){
          img.style.width = x + "px";
          slider.style.left = img.offsetWidth - (slider.offsetWidth / 2) + "px";
      }
  }
}

function compressRegulator(size){
  if(size>=0 && size<100){
    return 1;
  }else if(size>=100 && size<1000){
    return 10;
  }else if(size>=1000 && size<10000){
    return 100;
  }else{
    return size;
  }
}

async function increaseBase64Size(base64Image, requiredSizeKB, format) {
    function base64SizeKB(base64) {
        let len = base64.length * (3 / 4) - (base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0);
        return len / 1024;
    }

    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");

            ctx.drawImage(img, 0, 0);
            
            let quality = 0.95;
            let adjustedBase64;
            let finalSizeKB;

            while (quality <= 1.0) {
                adjustedBase64 = canvas.toDataURL(`image/${format}`, quality);
                finalSizeKB = base64SizeKB(adjustedBase64);
                if (finalSizeKB >= requiredSizeKB - 100 && finalSizeKB <= requiredSizeKB + 100) {
                    break;
                }
                quality += 0.01;
            }
            resolve(adjustedBase64);
        };
        img.onerror = () => reject("Failed to load image for resizing.");
        img.src = base64Image;
    });
}

function getMultiImageSizeKB(media_set){
  if(media_set.length!=0){
    let total_size=0;
    for(let i=0; i<media_set.length; i++){
      total_size += getBase64SizeKB(media_set[i]);
    }
    if(total_size>0){
      return total_size;
    }else{
      return 0;
    }
  }
  return null;
}
function getMultiImageLimit(media_set){
  if(media_set.length!=0){
    let total_limit=0;
    for(let i=0; i<media_set.length; i++){
      total_limit += Math.floor(getBase64SizeKB(media_set[i])/900)+2;
    }
    if(total_limit>0){
      return total_limit;
    }else{
      return 0;
    }
  }
  return null;
}

function overhead(image_set){
  if(image_set.length!=0){
    for(let i=0; i<image_set.length; i++){
      size = getBase64SizeKB(image_set[i]);
      if(size>900){
        return i+1;
      }
    }
    return 0;
  }
  return null;
}

async function getMediaBase64(url){
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error("Failed to fetch the image");
        }
        const contentType = response.headers.get("content-type");
      
        if (!contentType || !(contentType.startsWith("image/") || contentType.startsWith("video/"))) {
            return null;
        }
        const blob = await response.blob();
        return await convertBlobToBase64(blob);
    } catch (error) {
        system.handelPyError({'code': 400, 'message': 'Failed to fetch the media using provided URL, Please cross check that given URL is correct and publically open to fetch the media'});
        return null;
    }
}

function convertBlobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result); // Extract the Base64 data
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

function base64ToFile(base64String) {
  const match = base64String.match(/^data:(image\/[a-zA-Z0-9+]+|video\/[a-zA-Z0-9+]+);base64,(.+)$/);

    if (!match) {
        throw new Error("Invalid Base64 image format");
    }

    const mimeType = match[1];
    const base64Data = match[2];
    const extension = mimeType.split("/")[1];

    const byteCharacters = atob(base64Data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: mimeType });
    return new File([blob], `media.${extension}`, { type: mimeType });
}

async function getInerImage(url){
  const proxyUrl = `${window.location.origin}/proxy?url=${url}`;
  const base64Data = await getMediaBase64(proxyUrl); 
  if(base64Data==null){ 
    return system.handelPyError({'code': 415, 'message': 'Unsupported media format, Provided url get some unwanted media file or code files which are not valid according to CHS rules please try with some valid media'});;
  }else if(base64Data.startsWith('data:image/')){
    const file = base64ToFile(base64Data);
    const fileInput = document.getElementById("file-input");
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change'));
    const preview = document.querySelector('.preview');
    preview.innerHTML = `<img src=${base64Data} alt="loading.." />`;
    document.querySelector('.sample-dfd').style.display = 'none';
    system.closeGoogleURL();
  }else if(base64Data.startsWith('data:video/')){
    const file = base64ToFile(base64Data);
    const fileInput = document.getElementById("file-input");
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change'));
    const preview = document.querySelector('.preview');
    preview.innerHTML = `<video autoplay="" controls=""><source src=${base64Data} type="video/${base64Data.split(';')[0].split('/')[1]}"></video>`;
    document.querySelector('.sample-dfd').style.display = 'none';
    system.closeGoogleURL();
  }
}
