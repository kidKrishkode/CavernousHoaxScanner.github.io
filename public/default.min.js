let mediaType, url, dfd;
let converter;
let pdf;
function DFD(){
  this.active = true;
  this.signal = null;
}
function CONVERTER(){
  this.active = true;
  this.signal = null;
}
function IMGTOPDF(){
  this.active = true;
  this.signal = null;
  this.imgSet = [];
  this.view = 0;
}
document.addEventListener("DOMContentLoaded",() => {
  dfd = new DFD();
  converter = new CONVERTER();
  pdf= new IMGTOPDF();
});
DFD.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else if(file.type.startsWith('video/')){
            let video = document.createElement('video');
            video.autoplay = true;
            video.controls = true;
            video.muted = true;
            let source = document.createElement('source');
            source.src = dataURL;
            source.type = 'video/mp4';
            video.appendChild(source);
            preview.appendChild(video);
            mediaType = 'Video'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
DFD.prototype.getVideoDuration = function(videoPath){
  return new Promise((resolve, reject) => {
    var video = document.createElement('video');
    video.preload = 'metadata';
    video.onloadedmetadata = function(){
      var duration = video.duration;
      var xhr = new XMLHttpRequest();
      xhr.open('HEAD', videoPath, true);
      xhr.onreadystatechange = function(){
        if(xhr.readyState === 4){
          resolve({ duration });
        }
      };
      xhr.send();
    };
    video.onerror = function(){
      reject('Error to loading video');
    };
    video.src = videoPath;
  });
}
DFD.prototype.displayVinfo = function(path){
  dfd.getVideoDuration(path).then(info => {
    return Math.round(info.duration);
  }).catch(error => {
    console.error(error);
  });
}
DFD.prototype.engine_start = function(){
  dfd.engine_active();
}
DFD.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let dur = document.getElementById('media-due');
  let dim = document.getElementById('media-diamention');
  dfd.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      let dimensions = getMediaDimensions();
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        dfd.signal = true;
        size.textContent = temp+' Kb';
        dur.textContent = 'Static';
        dim.textContent = dimensions?.width+"x"+dimensions?.height;
      }else{
        inValidsizeError(temp);
        dfd.signal = false;
      }
    }else if(media[0] == 'Video'){
      let temp = Filevalidation(400 * 1024, 20);
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        dfd.signal = true;
        size.textContent = temp+' Kb';
        setTimeout(() => {
          let dimensions = getMediaDimensions();
          dim.textContent = dimensions?.width+"x"+dimensions?.height;
        }, 1000);
        dfd.getVideoDuration(media[1]).then(info => {
          dur.textContent = Math.round(info.duration)+' s';
        }).catch(error => {
          console.error(error);
          acc.textContent = 'Video inner data is corrupted!';
          dfd.signal = false;
        });
      }else{
        inValidsizeError(temp);
        dfd.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      dfd.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
function inValidsizeError(message){
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  acc.textContent = message;
  size.textContent = 'Null';
  try{
    system.handelPyError({code: 413, message: "The request media was larger than limits defined by CHS (lookup our media size restriction point in privacy page or docs page), please try something different media.."});
  }catch(e){
    alert("Media size is not processable, please try something different!");
  }
}
function Filevalidation(max, min){
  const fi = document.getElementById('file-input');
  const validFiles = eval(config.hex.vaildFiles);
  return validFiles(fi, max, min);
}
function getMediaDimensions(){
  let preview = document.querySelector('.preview');
  let media = preview.children[0];
  let dimensions;
  if(media.tagName.toLowerCase() === 'img'){
    dimensions = {
      width: media.naturalWidth,
      height: media.naturalHeight
    };
  }else if(media.tagName.toLowerCase() === 'video'){
    dimensions = {
      width: media.videoWidth,
      height: media.videoHeight
    };
  }else{
    dimensions = null;
  }
  return dimensions;
}

IMGTOPDF.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      for(let i=0; i<e.target.files.length; i++){
        let file = e.target.files[i];
        if(file){
          const reader = new FileReader();
          reader.onload = () => {
            const dataURL = reader.result;
            if(file.type.startsWith('image/')){
              mediaType = 'Image'; 
              pdf.imgSet[pdf.imgSet.length] = dataURL;
              resolve([mediaType, dataURL, e.target.files.length]);
            }else{
              reject('Unwanted media formate detected!');
            }
          };
          reader.readAsDataURL(file);
        }
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
IMGTOPDF.prototype.engine_start = function(){
  pdf.engine_active();
}
IMGTOPDF.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let count = document.getElementById('media-count');
  pdf.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        pdf.signal = true;
        size.textContent = temp+' Kb';
        count.textContent = media[2];
        pdf.setView();
        document.querySelector('.view-image').innerHTML = `<div class="btn btn-process" onclick="pdf.openView();"><i class="fa fa-eye"></i> View Images</div>`;
      }else{
        inValidsizeError(temp);
        pdf.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      pdf.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
IMGTOPDF.prototype.setView = function(){
  try{
    setTimeout(()=>{
      if(pdf.imgSet.length!=0){
        if(pdf.view!=0){
          document.body.removeChild(document.getElementById('pdfPreview'));
        }
        let temp = `<div class="workspace blbg" style="background: #0000009e;" id="pdfPreview"><div class="pdfView"><header class="flx"><img src="../public/favicon.ico" alt="load"/><div class="btn btn-outline-info dropdown-toggle" data-toggle="dropdown" onclick="pdf.sortView();">Re-Order</div><span style="cursor: pointer;" onclick="pdf.closeView();">&times;</span></header><div class="view">`;
        for(let i=0; i<pdf.imgSet.length; i++){
          temp += `<div class="page" draggable="true"><div class="img"><img src="${pdf.imgSet[i]}" alt="load" class="imp"/></div><div class="index">${i+1}</div></div>`;
        }
        temp += `</div></div></div>`;
        document.body.innerHTML += temp;
        pdf.view = 1;
      }
    },1000);
  }catch(e){
    console.log("Can't able to open Pdf view!");
  }
}
IMGTOPDF.prototype.sortView = function(){
  try{
    pdf.view=2;
    const element = document.getElementById("pdfPreview");
    const view = element.querySelector(".view");
    let temp = '<ul id="sortable">';
    let date = `${new Date().getDate()<10?'0'+new Date().getDate():new Date().getDate()}/${(new Date().getMonth()+1)<10?'0'+(new Date().getMonth()+1):(new Date().getMonth()+1)}/${new Date().getFullYear()}`;
    for(let i=0; i<pdf.imgSet.length; i++){
      temp += `<li class="flo" draggable="true"><span>Index: ${i+1}</span><img src="${pdf.imgSet[i]}" class="pdf-img" alt="load" width="30" height="42"/><span>Author: User</span><span>Modified: ${date}</span><span>Type: Image</span></li>`;
    }
    temp += '</ul>';
    view.innerHTML = temp;
    setTimeout(()=>{
      const sortableList = document.getElementById("sortable");
      const dragAndSort = eval(config.hex.dragAndSort);
      dragAndSort(sortableList);
    },1000);
  }catch(e){
    console.log("Can't able to open short view!");
  }
}
IMGTOPDF.prototype.openView = function(){
  if(pdf.view==2){
    document.body.removeChild(document.getElementById('pdfPreview'));
    pdf.view=0;
    pdf.setView();
  }
  setTimeout(()=>{
    document.getElementById('pdfPreview').style.display = "block";
    document.body.style.overflowY = "hidden";
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  },1000);
}
IMGTOPDF.prototype.closeView = function(){
  document.getElementById('pdfPreview').style.display = "none";
  document.body.style.overflowY = "auto";
}
CONVERTER.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
CONVERTER.prototype.engine_start = function(){
  converter.engine_active();
}
CONVERTER.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let path = document.getElementById('media-path');
  converter.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      if(temp>=4 && temp<=6580){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        converter.signal = true;
        size.textContent = temp+' Kb';
        path.textContent = media[1];
        // if(media[1].startsWith('data:image/')){
        //   acc.textContent = "Not Accepted";
        //   converter.signal = false;
        // }
      }else{
        inValidsizeError(temp);
      }
    }else{
      console.warn("Engine not work!");
    }
  }).catch(e => {
    console.log(e);
  });
}

function getBase64SizeKB(base64) {
  const base64Str = base64.split(',')[1] || base64;

  const padding = (base64Str.endsWith('==')) ? 2 : (base64Str.endsWith('=')) ? 1 : 0;
  const bytes = (base64Str.length * 3) / 4 - padding;

  return bytes / 1024;
}

async function compressBase64Image(base64_image, maxSizeKB = 900, minSkipSizeKB = 600) {
  function base64SizeKB(base64) {
    let len = base64.length * (3 / 4) - (base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0);
    return len / 1024;
  }

  if (base64SizeKB(base64_image) < minSkipSizeKB) {
    // Skip compression if already small enough
    return base64_image;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      let quality = 0.95;
      let compressedBase64;

      // Iteratively reduce quality until under maxSizeKB or minimum threshold
      while (quality >= 0.1) {
        compressedBase64 = canvas.toDataURL("image/jpeg", quality);
        const sizeKB = base64SizeKB(compressedBase64);

        if (sizeKB <= maxSizeKB) break;
        quality -= 0.05;
      }

      resolve(compressedBase64);
    };
    img.onerror = () => reject("Failed to load image for compression.");
    img.src = base64_image;
  });
}

function compressBase64Video(base64Video, targetMaxSizeMB = 10, minSkipSizeKB = 900) {
  const sizeKB = getBase64SizeKB(base64Video);
  if (sizeKB < minSkipSizeKB) {
    return Promise.resolve(base64Video); // No need to compress
  }

  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const blob = base64ToBlob(base64Video, 'video/mp4');
    const url = URL.createObjectURL(blob);

    video.src = url;
    video.crossOrigin = 'anonymous';
    video.muted = true;
    video.playsInline = true;

    video.addEventListener('loadedmetadata', () => {
      const stream = video.captureStream();
      const chunks = [];
      const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm',
        videoBitsPerSecond: 500_000, // compression control
      });

      recorder.ondataavailable = (e) => chunks.push(e.data);
      recorder.onstop = () => {
        const compressedBlob = new Blob(chunks, { type: 'video/webm' });
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result); // Return base64
        reader.onerror = reject;
        reader.readAsDataURL(compressedBlob);
        URL.revokeObjectURL(url);
      };

      recorder.start();
      video.play();

      setTimeout(() => {
        recorder.stop();
        video.pause();
      }, Math.min(video.duration * 1000, 40000)); // up to 40s or full duration
    });

    video.onerror = () => {
      reject("Video failed to load. Ensure base64 is valid and browser supports video playback.");
    };
  });
}


function base64ToBlob(base64, mimeType) {
  const base64Data = base64.split(',')[1] || base64;
  const byteChars = atob(base64Data);
  const byteArrays = [];
  for (let i = 0; i < byteChars.length; i += 512) {
    const slice = byteChars.slice(i, i + 512);
    const byteNumbers = new Array(slice.length);
    for (let j = 0; j < slice.length; j++) {
      byteNumbers[j] = slice.charCodeAt(j);
    }
    byteArrays.push(new Uint8Array(byteNumbers));
  }
  return new Blob(byteArrays, { type: mimeType });
}

async function extractFramesFromBase64Video(base64Video, fps = 1) {
    return new Promise((resolve, reject) => {
        const frames = [];

        // Create a video element
        const video = document.createElement('video');
        video.src = base64Video;
        video.crossOrigin = 'anonymous';
        video.preload = 'auto';
        video.muted = true;
        video.playsInline = true;

        video.addEventListener('loadedmetadata', () => {
            const duration = Math.floor(video.duration);
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            let currentTime = 0;

            function captureFrame() {
                video.currentTime = currentTime;
            }

            video.addEventListener('seeked', () => {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const base64Image = canvas.toDataURL('image/jpeg'); // or 'image/png'
                frames.push({ second: currentTime, image: base64Image });

                currentTime += 1;
                if (currentTime <= video.duration) {
                    captureFrame();
                } else {
                    resolve(frames);
                }
            });

            captureFrame();
        });

        video.addEventListener('error', (e) => reject(`Video error: ${e.message || e}`));
    });
}

function analyzeClassificationSequence(predictions) {
  if (!predictions || predictions.length === 0) {
      return { error: "Empty prediction list" };
  }

  let resultClass = "Real";
  let fakeSequences = [];
  let currentSequence = [];

  for (let i = 0; i < predictions.length; i++) {
      const item = predictions[i];
      const label = (item.class || "").toLowerCase();

      if (label === "fake") {
          currentSequence.push(item);
          if (currentSequence.length >= 2) {
              fakeSequences = [...currentSequence]; // copy
          }
      } else {
          currentSequence = [];
      }
  }

  if (fakeSequences.length > 0) {
      const totalAccuracy = fakeSequences.reduce((sum, f) => sum + f.accuracy, 0);
      const avgAccuracy = +(totalAccuracy / fakeSequences.length).toFixed(2);
      const startTime = fakeSequences[0].second;
      const endTime = fakeSequences[fakeSequences.length - 1].second;

      return {
          class: "Fake",
          accuracy: avgAccuracy,
          period: [startTime, endTime]
      };
  }

  // No valid fake sequence found, evaluate real data
  const realPreds = predictions.filter(p => (p.class || "").toLowerCase() === "real");
  if (realPreds.length > 0) {
      const totalAccuracy = realPreds.reduce((sum, p) => sum + p.accuracy, 0);
      const avgAccuracy = +(totalAccuracy / realPreds.length).toFixed(2);
      const startTime = realPreds[0].second;
      const endTime = realPreds[realPreds.length - 1].second;

      return {
          class: "Real",
          accuracy: avgAccuracy,
          period: [startTime, endTime]
      };
  }

  return { error: "No valid classification data" };
}

function summarizePrototypeResults(response_tree) {
  const summary = {};

  response_tree.forEach(entry => {
      for (let proto in entry) {
          const result = entry[proto];
          const label = result.class.toLowerCase();
          const accuracy = result.accuracy;

          if (!summary[proto]) {
              summary[proto] = {
                  real: { count: 0, totalAccuracy: 0 },
                  fake: { count: 0, totalAccuracy: 0 }
              };
          }

          if (label === "real") {
              summary[proto].real.count += 1;
              summary[proto].real.totalAccuracy += accuracy;
          } else if (label === "fake") {
              summary[proto].fake.count += 1;
              summary[proto].fake.totalAccuracy += accuracy;
          }
      }
  });

  const resultList = [];

  for (let proto in summary) {
      const real = summary[proto].real;
      const fake = summary[proto].fake;

      let finalClass, finalAccuracy;

      if (fake.count > real.count) {
          finalClass = "Fake";
          finalAccuracy = +(fake.totalAccuracy / fake.count).toFixed(2);
      } else {
          finalClass = "Real";
          finalAccuracy = +(real.totalAccuracy / real.count).toFixed(2);
      }

      resultList[proto] = {
          class: finalClass,
          accuracy: finalAccuracy
      };
  }

  return resultList;
}

function getAspectRatio(width, height) {
  const inputRatio = width / height;
  
  // Define standard ratios
  const ratios = {
      "16:9": 16 / 9,
      "9:16": 9 / 16,
      "1:1": 1,
      "3:2": 3 / 2
  };

  let closestMatch = 'custom';
  let smallestDiff = Infinity;

  for (const [label, ratio] of Object.entries(ratios)) {
      const diff = Math.abs(inputRatio - ratio);
      if (diff < 0.05) {  // allow small tolerance
          if (diff < smallestDiff) {
              smallestDiff = diff;
              closestMatch = label;
          }
      }
  }

  return closestMatch;
}
