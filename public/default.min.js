let mediaType, url, dfd;
let converter;
let pdf;
function DFD(){
  this.active = true;
  this.signal = null;
}
function CONVERTER(){
  this.active = true;
  this.signal = null;
}
function IMGTOPDF(){
  this.active = true;
  this.signal = null;
  this.imgSet = [];
  this.view = 0;
}
document.addEventListener("DOMContentLoaded",() => {
  dfd = new DFD();
  converter = new CONVERTER();
  pdf= new IMGTOPDF();
});
DFD.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else if(file.type.startsWith('video/')){
            let video = document.createElement('video');
            video.autoplay = true;
            video.controls = true;
            video.muted = true;
            let source = document.createElement('source');
            source.src = dataURL;
            source.type = 'video/mp4';
            video.appendChild(source);
            preview.appendChild(video);
            mediaType = 'Video'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
DFD.prototype.getVideoDuration = function(videoPath){
  return new Promise((resolve, reject) => {
    var video = document.createElement('video');
    video.preload = 'metadata';
    video.onloadedmetadata = function(){
      var duration = video.duration;
      var xhr = new XMLHttpRequest();
      xhr.open('HEAD', videoPath, true);
      xhr.onreadystatechange = function(){
        if(xhr.readyState === 4){
          resolve({ duration });
        }
      };
      xhr.send();
    };
    video.onerror = function(){
      reject('Error to loading video');
    };
    video.src = videoPath;
  });
}
DFD.prototype.displayVinfo = function(path){
  dfd.getVideoDuration(path).then(info => {
    return Math.round(info.duration);
  }).catch(error => {
    console.error(error);
  });
}
DFD.prototype.engine_start = function(){
  dfd.engine_active();
}
DFD.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let dur = document.getElementById('media-due');
  let dim = document.getElementById('media-diamention');
  dfd.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      let dimensions = getMediaDimensions();
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        dfd.signal = true;
        size.textContent = temp+' Kb';
        dur.textContent = 'Static';
        dim.textContent = dimensions?.width+"x"+dimensions?.height;
      }else{
        inValidsizeError(temp);
        dfd.signal = false;
      }
    }else if(media[0] == 'Video'){
      let temp = Filevalidation(60 * 1024, 200);
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        dfd.signal = true;
        size.textContent = temp+' Kb';
        setTimeout(() => {
          let dimensions = getMediaDimensions();
          dim.textContent = dimensions?.width+"x"+dimensions?.height;
        }, 1000);
        dfd.getVideoDuration(media[1]).then(info => {
          dur.textContent = Math.round(info.duration)+' s';
        }).catch(error => {
          console.error(error);
          acc.textContent = 'Video inner data is corrupted!';
          dfd.signal = false;
        });
      }else{
        inValidsizeError(temp);
        dfd.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      dfd.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
function inValidsizeError(message){
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  acc.textContent = message;
  size.textContent = 'Null';
  try{
    system.handelPyError({code: 413, message: "The request media was larger than limits defined by CHS (lookup our media size restriction point in privacy page or docs page), please try something different media.."});
  }catch(e){
    alert("Media size is not processable, please try something different!");
  }
}
function Filevalidation(max, min){
  const fi = document.getElementById('file-input');
  const validFiles = eval(config.hex.vaildFiles);
  return validFiles(fi, max, min);
}
function getMediaDimensions(){
  let preview = document.querySelector('.preview');
  let media = preview.children[0];
  let dimensions;
  if(media.tagName.toLowerCase() === 'img'){
    dimensions = {
      width: media.naturalWidth,
      height: media.naturalHeight
    };
  }else if(media.tagName.toLowerCase() === 'video'){
    dimensions = {
      width: media.videoWidth,
      height: media.videoHeight
    };
  }else{
    dimensions = null;
  }
  return dimensions;
}

IMGTOPDF.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      for(let i=0; i<e.target.files.length; i++){
        let file = e.target.files[i];
        if(file){
          const reader = new FileReader();
          reader.onload = () => {
            const dataURL = reader.result;
            if(file.type.startsWith('image/')){
              mediaType = 'Image'; 
              pdf.imgSet[pdf.imgSet.length] = dataURL;
              resolve([mediaType, dataURL, e.target.files.length]);
            }else{
              reject('Unwanted media formate detected!');
            }
          };
          reader.readAsDataURL(file);
        }
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
IMGTOPDF.prototype.engine_start = function(){
  pdf.engine_active();
}
IMGTOPDF.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let count = document.getElementById('media-count');
  pdf.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      if(temp>=0){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        pdf.signal = true;
        size.textContent = temp+' Kb';
        count.textContent = media[2];
        pdf.setView();
        document.querySelector('.view-image').innerHTML = `<div class="btn btn-process" onclick="pdf.openView();"><i class="fa fa-eye"></i> View Images</div>`;
      }else{
        inValidsizeError(temp);
        pdf.signal = false;
      }
    }else{
      console.warn("Engine not work!");
      pdf.signal = false;
    }
  }).catch(e => {
    console.log(e);
  });
}
IMGTOPDF.prototype.setView = function(){
  try{
    setTimeout(()=>{
      if(pdf.imgSet.length!=0){
        if(pdf.view!=0){
          document.body.removeChild(document.getElementById('pdfPreview'));
        }
        let temp = `<div class="workspace blbg" style="background: #0000009e;" id="pdfPreview"><div class="pdfView"><header class="flx"><img src="../public/favicon.ico" alt="load"/><div class="btn btn-outline-info dropdown-toggle" data-toggle="dropdown" onclick="pdf.sortView();">Re-Order</div><span style="cursor: pointer;" onclick="pdf.closeView();">&times;</span></header><div class="view">`;
        for(let i=0; i<pdf.imgSet.length; i++){
          temp += `<div class="page" draggable="true"><div class="img"><img src="${pdf.imgSet[i]}" alt="load" class="imp"/></div><div class="index">${i+1}</div></div>`;
        }
        temp += `</div></div></div>`;
        document.body.innerHTML += temp;
        pdf.view = 1;
      }
    },1000);
  }catch(e){
    console.log("Can't able to open Pdf view!");
  }
}
IMGTOPDF.prototype.sortView = function(){
  try{
    pdf.view=2;
    const element = document.getElementById("pdfPreview");
    const view = element.querySelector(".view");
    let temp = '<ul id="sortable">';
    let date = `${new Date().getDate()<10?'0'+new Date().getDate():new Date().getDate()}/${(new Date().getMonth()+1)<10?'0'+(new Date().getMonth()+1):(new Date().getMonth()+1)}/${new Date().getFullYear()}`;
    for(let i=0; i<pdf.imgSet.length; i++){
      temp += `<li class="flo" draggable="true"><span>Index: ${i+1}</span><img src="${pdf.imgSet[i]}" class="pdf-img" alt="load" width="30" height="42"/><span>Author: User</span><span>Modified: ${date}</span><span>Type: Image</span></li>`;
    }
    temp += '</ul>';
    view.innerHTML = temp;
    setTimeout(()=>{
      const sortableList = document.getElementById("sortable");
      const dragAndSort = eval(config.hex.dragAndSort);
      dragAndSort(sortableList);
    },1000);
  }catch(e){
    console.log("Can't able to open short view!");
  }
}
IMGTOPDF.prototype.openView = function(){
  if(pdf.view==2){
    document.body.removeChild(document.getElementById('pdfPreview'));
    pdf.view=0;
    pdf.setView();
  }
  setTimeout(()=>{
    document.getElementById('pdfPreview').style.display = "block";
    document.body.style.overflowY = "hidden";
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  },1000);
}
IMGTOPDF.prototype.closeView = function(){
  document.getElementById('pdfPreview').style.display = "none";
  document.body.style.overflowY = "auto";
}
CONVERTER.prototype.mediaChange = function(){
  return new Promise((resolve, reject) => {
    const fileInput = document.getElementById('file-input');
    const preview = document.querySelector('.preview');
    const placeholder = document.querySelector('.placeholder');
    const dropBox = document.querySelector('.drop-box');
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          preview.innerHTML = '';
          if(file.type.startsWith('image/')){
            const img = document.createElement('img');
            img.src = dataURL;
            preview.appendChild(img);
            mediaType = 'Image'; 
            url = dataURL;
            resolve([mediaType, url]);
          }else{
            reject('Unwanted media formate detected!');
          }
          placeholder.style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    });
  
    dropBox.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    dropBox.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      fileInput.dispatchEvent(new Event('change'));
    });
  });
}
CONVERTER.prototype.engine_start = function(){
  converter.engine_active();
}
CONVERTER.prototype.engine_active = function(){
  let type = document.getElementById('media-type');
  let acc = document.getElementById('media-acc');
  let size = document.getElementById('media-size');
  let path = document.getElementById('media-path');
  converter.mediaChange().then(media => {
    if(media[0] == 'Image'){
      let temp = Filevalidation(30 * 1024, 5);
      if(temp>=4 && temp<=6580){
        type.textContent = media[0].toString();
        acc.textContent = "Accepted";
        converter.signal = true;
        size.textContent = temp+' Kb';
        path.textContent = media[1];
        // if(media[1].startsWith('data:image/')){
        //   acc.textContent = "Not Accepted";
        //   converter.signal = false;
        // }
      }else{
        inValidsizeError(temp);
      }
    }else{
      console.warn("Engine not work!");
    }
  }).catch(e => {
    console.log(e);
  });
}

function getBase64SizeKB(base64) {
  const base64Str = base64.split(',')[1] || base64;

  const padding = (base64Str.endsWith('==')) ? 2 : (base64Str.endsWith('=')) ? 1 : 0;
  const bytes = (base64Str.length * 3) / 4 - padding;

  return bytes / 1024;
}

async function compressBase64Image(base64_image, maxSizeKB = 900, minSkipSizeKB = 600) {
  function base64SizeKB(base64) {
    let len = base64.length * (3 / 4) - (base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0);
    return len / 1024;
  }

  if (base64SizeKB(base64_image) < minSkipSizeKB) {
    // Skip compression if already small enough
    return base64_image;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      let quality = 0.95;
      let compressedBase64;

      // Iteratively reduce quality until under maxSizeKB or minimum threshold
      while (quality >= 0.1) {
        compressedBase64 = canvas.toDataURL("image/jpeg", quality);
        const sizeKB = base64SizeKB(compressedBase64);

        if (sizeKB <= maxSizeKB) break;
        quality -= 0.05;
      }

      resolve(compressedBase64);
    };
    img.onerror = () => reject("Failed to load image for compression.");
    img.src = base64_image;
  });
}

async function compressBase64Video(base64Video, targetMaxSizeMB = 10, minSkipSizeKB = 900) {
  const sizeKB = getBase64SizeKB(base64Video);
  if (sizeKB < minSkipSizeKB) {
    return base64Video; // Skip compression
  }

  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const blob = base64ToBlob(base64Video, 'video/mp4');
    const url = URL.createObjectURL(blob);
    video.src = url;
    video.crossOrigin = "anonymous";
    video.muted = true; // Needed for autoplay

    video.addEventListener('loadeddata', async () => {
      const stream = video.captureStream();
      const chunks = [];
      const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm', // WebM is typically smaller
        videoBitsPerSecond: 500_000, // Approx 500kbps for size control
      });

      recorder.ondataavailable = (e) => chunks.push(e.data);
      recorder.onstop = async () => {
        const compressedBlob = new Blob(chunks, { type: 'video/webm' });
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64Compressed = reader.result;
          resolve(base64Compressed);
        };
        reader.onerror = reject;
        reader.readAsDataURL(compressedBlob);
      };

      recorder.start();
      video.play();

      video.onended = () => {
        recorder.stop();
        URL.revokeObjectURL(url);
      };
    });

    video.onerror = (err) => {
      reject("Failed to load video for compression.");
    };
  });
}

function base64ToBlob(base64, mimeType) {
  const base64Data = base64.split(',')[1] || base64;
  const byteChars = atob(base64Data);
  const byteArrays = [];
  for (let i = 0; i < byteChars.length; i += 512) {
    const slice = byteChars.slice(i, i + 512);
    const byteNumbers = new Array(slice.length);
    for (let j = 0; j < slice.length; j++) {
      byteNumbers[j] = slice.charCodeAt(j);
    }
    byteArrays.push(new Uint8Array(byteNumbers));
  }
  return new Blob(byteArrays, { type: mimeType });
}
