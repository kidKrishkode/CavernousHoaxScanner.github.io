# -*- coding: utf-8 -*-
"""mesonet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17M4FJkSVaOSs4A2TCBqfrXcCkXpO-J5r
"""

import kagglehub
# yihaopuah_deep_fake_images_path = kagglehub.dataset_download('yihaopuah/deep-fake-images')
# mayankjha146025_fake_face_images_generated_from_different_gans_path = kagglehub.dataset_download('mayankjha146025/fake-face-images-generated-from-different-gans')
# bishalrajbanshi_realanddeepfakeimage_path = kagglehub.dataset_download('bishalrajbanshi/realanddeepfakeimage')
# sanikatiwarekar_deep_fake_detection_dfd_entire_original_dataset_path = kagglehub.dataset_download('sanikatiwarekar/deep-fake-detection-dfd-entire-original-dataset')
shivamardeshna_real_and_fake_images_dataset_for_image_forensics_path = kagglehub.dataset_download('shivamardeshna/real-and-fake-images-dataset-for-image-forensics')
# abdullah122_rvf10k_10_path = kagglehub.dataset_download('abdullah122/rvf10k-10')

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, accuracy_score
from tensorflow.keras.layers import Input, Dense, Flatten, Conv2D, MaxPooling2D, BatchNormalization, Dropout, LeakyReLU, GlobalAveragePooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.models import Model, load_model
from tensorflow.keras.callbacks import ModelCheckpoint, ReduceLROnPlateau, EarlyStopping
from tensorflow.keras.utils import to_categorical
import os

image_dimensions = {'height': 256, 'width': 256, 'channels': 3}

class Classifier:
    def __init__(self):
        self.model = None

    def predict(self, x):
        return self.model.predict(x)

    def load(self, path):
        self.model = load_model(path)

class Meso4(Classifier):
    def __init__(self, learning_rate=0.0001):
        self.model = self.init_model()
        optimizer = Adam(learning_rate=learning_rate)
        self.model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

    def init_model(self):
        x = Input(shape=(image_dimensions['height'],
                         image_dimensions['width'],
                         image_dimensions['channels']))

        # First Conv Block
        x1 = Conv2D(16, (3, 3), padding='same', activation='relu')(x)
        x1 = BatchNormalization()(x1)
        x1 = MaxPooling2D(pool_size=(2, 2), padding='same')(x1)

        # Second Conv Block
        x2 = Conv2D(32, (5, 5), padding='same', activation='relu')(x1)
        x2 = BatchNormalization()(x2)
        x2 = MaxPooling2D(pool_size=(2, 2), padding='same')(x2)

        # Third Conv Block
        x3 = Conv2D(64, (5, 5), padding='same', activation='relu')(x2)
        x3 = BatchNormalization()(x3)
        x3 = MaxPooling2D(pool_size=(2, 2), padding='same')(x3)

        # Fourth Conv Block
        x4 = Conv2D(64, (5, 5), padding='same', activation='relu')(x3)
        x4 = BatchNormalization()(x4)
        x4 = MaxPooling2D(pool_size=(4, 4), padding='same')(x4)

        # Fully Connected Layers
        y = GlobalAveragePooling2D()(x4)
        y = Dropout(0.5)(y)
        y = Dense(32)(y)
        y = LeakyReLU(negative_slope=0.1)(y)
        y = Dropout(0.5)(y)
        y = Dense(1, activation='softmax')(y)

        return Model(inputs=x, outputs=y)

# Instantiate the model
meso = Meso4(learning_rate=0.0001)

# Image augmentation
dataGenerator = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    brightness_range=[0.8, 1.2],
    horizontal_flip=True,
    zoom_range=0.2
)

# Data generators for train, validation, and test
train_generator = dataGenerator.flow_from_directory(
    shivamardeshna_real_and_fake_images_dataset_for_image_forensics_path+'/Data Set 1/Data Set 1/train',
    target_size=(256, 256),
    batch_size=32,
    class_mode='binary'
)

valid_generator = dataGenerator.flow_from_directory(
    shivamardeshna_real_and_fake_images_dataset_for_image_forensics_path+'/Data Set 1/Data Set 1/validation',
    target_size=(256, 256),
    batch_size=32,
    class_mode='binary'
)

test_generator = dataGenerator.flow_from_directory(
    shivamardeshna_real_and_fake_images_dataset_for_image_forensics_path+'/Data Set 1/Data Set 1/test',
    target_size=(256, 256),
    batch_size=32,
    class_mode='binary'
)

# Class weights for handling imbalanced dataset
class_weights = {0: 1.5, 1: 1.0}  # Adjust based on dataset balance

# Callbacks for training
epochs = 5
checkpoint = ModelCheckpoint('best_model.keras', save_best_only=True, monitor='val_accuracy', mode='max')
lr_scheduler = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=1e-7)
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

# Train the model
history = meso.model.fit(
    train_generator,
    validation_data=valid_generator,
    epochs=epochs,
    class_weight=class_weights,
    callbacks=[checkpoint, lr_scheduler, early_stopping]
)
meso.model.save('./models/final_model.keras')

# Plot training history
plt.plot(history.history['accuracy'], label='Train Accuracy', color='red')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', color='blue')
plt.legend()
plt.show()

plt.plot(history.history['loss'], label='Train Loss', color='red')
plt.plot(history.history['val_loss'], label='Validation Loss', color='blue')
plt.legend()
plt.show()

# Evaluate the model on the test set
test_loss, test_accuracy = meso.model.evaluate(test_generator)
print(f'Test Accuracy: {test_accuracy:.4f}')

# Predictions for confusion matrix
all_preds, all_labels = [], []
for i in range(len(valid_generator)):
    X, y = next(valid_generator)
    preds = (meso.predict(X) >= 0.5).astype(int)
    all_preds.extend(preds.flatten())
    all_labels.extend(y.flatten().astype(int))

# Calculate accuracy and plot confusion matrix
accuracy = accuracy_score(all_labels, all_preds)
print(f'Validation Accuracy: {accuracy:.4f}')

cm = confusion_matrix(all_labels, all_preds, labels=[0, 1])
cmd = ConfusionMatrixDisplay(cm, display_labels=['Fake', 'Real'])
cmd.plot(cmap=plt.cm.Blues)
plt.title('Confusion Matrix')
plt.show()
